---
title: Using Svelte Context to commmunicate between parent and child components 
date: 2021-08-02T00:00:00
summary: Learning stuff by borrowing from smarter people (Not me, I'm the one learning â€” in this case the smarter people are IBM).
---

One of my favorite talks at this year's [Svelte Summit](https://sveltesummit.com/) was [Untangling Composition and Higher Order Components](https://youtu.be/fnr9XWvjJHw?t=3472) by [Isaac Hagoal](https://twitter.com/isaac_hagoel). The techniques discussed are great for publishing your own components and you should definitely check it out (and the whole Summit, for that matter). 

However, there was a pattern I learned recently that wasn't mentioned in the talk, so I figured I'd write about it. If you don't want the *context* (pun!), you can skip to [the actual code](#the-actual-code). 

*This article assumes a basic understanding of Svelte's [Context API](https://svelte.dev/docs#setContext) and [slots](https://svelte.dev/docs#slot).*

### Great artists steal

There are a lot of tutorials, courses, and blog posts dealing with the basics of languages/frameworks. But when it comes to next steps and more "philosophical" coding topics (architecture, design, patterns, etc) there seems to be a little bit of a drought. So, I've taken to finding real world examples of smart people who are already doing the things I'm looking for. 

One such example is IBM's carbon-components library (and for me specifically, [carbon-components-svelte](https://github.com/IBM/carbon-components-svelte)). The components themselves are great, but the real value I found was digging into the source code and learning new patterns for component composition.

### Why I needed a pattern

Shortly before the Summit, I decided to write a package and publish it on `npm` -- it was something I had never done before and I like learning by doing. To avoid scrutiny, I settled on writing a parallax effect component for Svelte (parallax seems to be frowned upon these days so I figured no one would notice if I ended up publishing garbage ðŸ˜…). 

The basic design: a parent component that takes some global config props and a child component that could be nested inside the parent. The child component uses a mix of the parent's props and its own props for animation. There can be any number of children nested inside the parent. The `Parent` eventually looked something like this (very, very abridged for clarity):

```svelte
<!-- Parent.svelte -->
<script>
  // props to be passed in
  export let config;
  export let cancel; // to cancel animation -- for a11y!

  // and some local variables
  let scrollY; // bind:scrollY
  let innerHeight; // bind:innerHeight
</script>

...

<div>
  <!-- child components go here -->
  <slot />
</div>
```

The `Child` component contains functions that need those props and local vars, but I had a (self-imposed) restriction -- to avoid using the [`let` directive](https://svelte.dev/tutorial/slot-props). 

I wanted as little boilerplate as possible and if the user wanted a large number of `Child` components, they would end up manually passing down the `Parent` props many times. And that could open them up to bugs or unexpected behavior. 

In order to "hide" this prop passing, I reached for `context`. But `context` isn't reactive by default, so I had to make my `Parent` vars (and props) into stores so they could change in `Child` as well:

```svelte
<!-- Parent.svelte -->
<script>
  import { setContext } from 'svelte';
  import { writable } from 'svelte/store';
  
  export let config;
  export let cancel;

  // make a store version of the prop
  const _config = writable(config);
  // reactive statement to keep them in sync
  $: $_config = config;

  // ...and again
  const _cancel = writable(cancel);
  $: $_cancel = cancel;

  const scrollY = writable(0);
  const innerHeight = writable(0);

  setContext('contextKey', {
    _config,
    _cancel,
    scrollY,
    innerHeight
  });
</script>
```

And that seemed...ok, I guess? It worked, but I thought it was kind of ugly (in the actual code there were a lot more props and local vars). I had a bunch of unnecessary stores and redeclared variables prefixed with underscores -- it got pretty tedious whenever I wanted to change something.

But then I remembered a cool pattern I had come across in the IBM component library. It goes a little something like this: instead of passing all those props and vars *down* to the children, you pass functions that take them as arguments *up* to the parent. Rad!

### The actual code!

First we set up our `context` and an array to hold the children and their methods. The `context` itself contains two methods -- one for adding a `Child` and one for removing it:

```svelte
<!-- Parent.svelte -->
<script>
  import { setContext } from 'svelte';

  export let config;
  export let cancel;

  let scrollY;
  let innerHeight;

  // eventually full of Child objects with methods
  let children = [];

  // methods for Child to add/remove itself from `children`
  setContext('contextKey', {
    add: (child) => {
      children = [...children, child];
    },
    remove: (child) => {
      children = children.filter(c => c !== child);
    }
  });
</script>
```

Then, in `Child.svelte` we grab the `context`, set up our object, and call `add` in `onMount`:

```svelte
<!-- Child.svelte -->
<script>
  import { onMount, getContext } from 'svelte';

  // grab context
  const { add, remove } = getContext('contextKey');

  // Child object with fancy method
  const child = {
    func: (scrollY, innerHeight, cancel) => {
      // eventually do stuff with those values
    }
  };

  onMount(() => {
    // add it to the array in Parent
    add(child);

    return () => {
      // clean up!
      remove(child);
    }
  });
</script>
```

And then use it in `Parent.svelte`:

```javascript
$: children.forEach(child => {
     child.func(scrollY, innerHeight, cancel));
   });
```

Now, whenever the props and vars change in `Parent`, those methods will be re-run and the changes will be reflected in `Child`! There's less visual noise and it's still pretty clear what's going on. 

Another cool side-effect of this pattern is that the parent component can get all kinds of information about children (for example, you can get `children.length` -- can't do that with `$$slots`). You can also add meta info to the `Child` object:

```javascript
const child = {
  name: `${nameProp}`,
  type: `${typeProp}`,
  props: ['some', 'other', 'props'],
  func: (scrollY, innerHeight, cancel) => {
    // do stuff!
  }
}
```

So, even if you don't use the components in your projects, I highly recommend checking out IBM's [carbon-components-svelte](https://github.com/IBM/carbon-components-svelte) -- there are so many neat ideas and patterns to be found. And why struggle through problems when smarter people already beat us to it? (*Something, something, reinvented wheels.*)

*If you want to see this pattern in action, you can check out my actual project here -- [svelte-parallax](https://github.com/kindoflew/svelte-parallax).*
